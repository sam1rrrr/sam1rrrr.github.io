<!DOCTYPE html>
<!-- saved from url=(0028)http://nedosite.tk/draw.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Draw</title>
    <link rel="shortcut icon" href="img/favicon.ico">
    <script src="./draw_files/browser.min.js.Без названия"></script>

    <style>
        body {
            background-color: #BF55EC;
        }

        #canv {
            position: absolute;
            top: 0;right: 0;bottom: 0;left: 0;
            margin: auto;
            background-color: white;
        }
        *::selection {
   background: transparent;
}
*::-moz-selection {
   background: transparent;
}
    </style>
</head>
<body>
    <canvas id="canv" style="display: block;" width="0" height="0"></canvas>
<button onclick="saveCanvasAsImageFile()" class="download-button">
Скачать рисунок
</button>
 <style>
 .download-button{
     background-color: white;
     width: 200px;
     height: 100px;
     border: 4px solid black;
     border-radius: 30px;
     font-size: 30px;
 }
 img{
     width: 100px;
     height: 100px;
     background-color: #BF55EC; }
     button{
         background-color: #BF55EC;
         border: 0px
     }
    </style>
<!--  <script>
    var snowmax=300;
var snowcolor=new Array("#AAAACC","#DDDDFF","#CCCCDD","#F3F3F3","#F0FFFF","#FFFFFF","#EFF5FF")
var snowtype=new Array("Arial Black","Arial Narrow","Times","Comic Sans MS");
var snowletter="*";
var sinkspeed=0.6;
var snowmaxsize=20;
var snowminsize=8;
var snowingzone=1;


var snow=new Array();
var marginbottom;
var marginright;
var timer;
var i_snow=0;
var x_mv=new Array();
var crds=new Array();
var lftrght=new Array();
var browserinfos=navigator.userAgent;
var ie5=document.all&&document.getElementById&&!browserinfos.match(/Opera/);
var ns6=document.getElementById&&!document.all;
var opera=browserinfos.match(/Opera/);
var browserok=ie5||ns6||opera;
function randommaker(range) {
    rand=Math.floor(range*Math.random());
    return rand;
}
function initsnow() {
    if (ie5 || opera) {
        marginbottom=document.body.clientHeight;
        marginright=document.body.clientWidth;
    }
    else if (ns6) {
        marginbottom=window.innerHeight;
        marginright=window.innerWidth;
    }
    var snowsizerange=snowmaxsize-snowminsize;
    for (i=0;i<=snowmax;i++) {
        crds[i]=0;
        lftrght[i]=Math.random()*15;
        x_mv[i]=0.03+Math.random()/10;
        snow[i]=document.getElementById("s"+i);
        snow[i].style.fontFamily=snowtype[randommaker(snowtype/length)];
        snow[i].size=randommaker(snowsizerange)+snowminsize;
        snow[i].style.fontSize=snow[i].size+"px";
        snow[i].style.color=snowcolor[randommaker(snowcolor.length)];
        snow[i].sink=sinkspeed*snow[i].size/5;
        if (snowingzone==1) {snow[i].posx=randommaker(marginright-snow[i].size)}
        if (snowingzone==2) {snow[i].posx=randommaker(marginright/2-snow[i].size)}
        if (snowingzone==3) {snow[i].posx=randommaker(marginright/2-snow[i].size)+marginright/4}
        if (snowingzone==4) {snow[i].posx=randommaker(marginright/2-snow[i].size)+marginright/2}
        snow[i].posy=randommaker(2*marginbottom-marginbottom-2*snow[i].size);
        snow[i].style.left=snow[i].posx+"px";
        snow[i].style.top=snow[i].posy+"px";
    }
    movesnow();
}
function movesnow() {
    for(i=0;i<=snowmax;i++) {
        crds[i]+=x_mv[i];
        snow[i].posy+=snow[i].sink;
        snow[i].style.left=snow[i].posx+lftrght[i]*Math.sin(crds[i])+"px";
        snow[i].style.top=snow[i].posy+"px";
        if (snow[i].posy>=marginbottom-2*snow[i].size || parseInt(snow[i].style.left)>(marginright-3*lftrght[i])) {
            if (snowingzone==1) {snow[i].posx=randommaker(marginright-snow[i].size)}
            if (snowingzone==2) {snow[i].posx=randommaker(marginright/2-snow[i].size)}
            if (snowingzone==3) {snow[i].posx=randommaker(marginright/2-snow[i].size)+marginright/4}
            if (snowingzone==4) {snow[i].posx=randommaker(marginright/2-snow[i].size)+marginright/2}
            snow[i].posy=0;
        }
    }
    var timer=setTimeout("movesnow()",50);
}
for (i=0;i<=snowmax;i++) {
    document.write("<span id='s"+i+"' style='position:absolute;top:-"+snowmaxsize+"px;'>"+snowletter+"</span>");
}
if (browserok) {
    window.onload=initsnow;
}
    </script> -->
   <script>
    function testDrawing(){
    var canvas = document.getElementById("canv");
    var context = canvas.getContext("2d");

    context.save();
    context.beginPath();
    context.moveTo(10, 10);
    context.lineTo(290, 290);
    context.stroke();
    context.restore();
}

function getImage(canvas){
    var imageData = canvas.toDataURL();
    var image = new Image();
    image.src = imageData;
    return image;
}

function saveImage(image) {
    var link = document.createElement("a");
    link.setAttribute("href", image.src);
    link.setAttribute("download", "image");
    link.click();
}

testDrawing();

function saveCanvasAsImageFile(){
    var image = getImage(document.getElementById("canv"));
    saveImage(image);
}
    </script>
    <script>

        function DCanvas(el)
        {
            const ctx = el.getContext('2d');
            const pixel = 20;

            let is_mouse_down = false;

            canv.width = prompt("Ширина рисунка (в пикселях)");
            if(canv.width > 700){
                alert("Слишком большая ширина!");
                location.reload()

            }
            canv.height = prompt("Высота рисунка (в пикселях)");
            if(canv.width > 700){
                alert("Слишком большая высота!");
                location.reload()

            }

            this.drawLine = function(x1, y1, x2, y2, color = 'gray') {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineJoin = 'miter';
                ctx.lineWidth = 1;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            this.drawCell = function(x, y, w, h) {
                ctx.fillStyle = 'blue';
                ctx.strokeStyle = 'blue';
                ctx.lineJoin = 'miter';
                ctx.lineWidth = 1;
                ctx.rect(x, y, w, h);
                ctx.fill();
            }

            this.clear = function() {
                ctx.clearRect(0, 0, canv.width, canv.height);
            }

            this.drawGrid = function() {
                const w = canv.width;
                const h = canv.height;
                const p = w / pixel;

                const xStep = w / p;
                const yStep = h / p;

                for( let x = 0; x < w; x += xStep )
                {
                    this.drawLine(x, 0, x, h);
                }

                for( let y = 0; y < h; y += yStep )
                {
                    this.drawLine(0, y, w, y);
                }
            }

            this.calculate = function(draw = false) {
                const w = canv.width;
                const h = canv.height;
                const p = w / pixel;

                const xStep = w / p;
                const yStep = h / p;

                const vector = [];
                let __draw = [];

                for( let x = 0; x < w; x += xStep )
                {
                    for( let y = 0; y < h; y += yStep )
                    {
                        const data = ctx.getImageData(x, y, xStep, yStep);

                        let nonEmptyPixelsCount = 0;
                        for( i = 0; i < data.data.length; i += 10 )
                        {
                            const isEmpty = data.data[i] === 0;

                            if( !isEmpty )
                            {
                                nonEmptyPixelsCount += 1;
                            }
                        }

                        if( nonEmptyPixelsCount > 1 && draw )
                        {
                            __draw.push([x, y, xStep, yStep]);
                        }

                        vector.push(nonEmptyPixelsCount > 1 ? 1 : 0);
                    }
                }

                if( draw )
                {
                    this.clear();
                    this.drawGrid();

                    for( _d in __draw )
                    {
                        this.drawCell( __draw[_d][0], __draw[_d][1], __draw[_d][2], __draw[_d][3] );
                    }
                }

                return vector;
            }

            el.addEventListener('mousedown', function(e) {
                is_mouse_down = true;
                ctx.beginPath();
            })

            el.addEventListener('mouseup', function(e) {
                is_mouse_down = false;
            })

            el.addEventListener('mousemove', function(e) {
                if( is_mouse_down )
                {
                    ctx.fillStyle = 'red';
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = pixel;

                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(e.offsetX, e.offsetY, pixel / 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(e.offsetX, e.offsetY);
                }
            })
        }

        let vector = [];
        let net = null;
        let train_data = [];

        const d = new DCanvas(document.getElementById('canv'));

        document.addEventListener('keypress', function(e) {
            if( e.key.toLowerCase() == 'c' )
            {
                d.clear();
            }

            if( e.key.toLowerCase() == '' )
            {
                vector = d.calculate(true);

                //train
                if( confirm('Positive?') )
                {
                    train_data.push({
                        input: vector,
                        output: {positive: 1}
                    });
                } else
                {
                    train_data.push({
                        input: vector,
                        output: {negative: 1}
                    });
                }
            }

            if( e.key.toLowerCase() == '' )
            {
                net = new brain.NeuralNetwork();
                net.train(train_data, {log: true});

                const result = brain.likely(d.calculate(), net);
                alert(result);
            }
        });
    </script>



</body></html>